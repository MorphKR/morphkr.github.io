"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[547],{31024:(t,e,i)=>{let s,n,o,r,l,a,h;i.d(e,{HK:()=>ib,PT:()=>b,Zc:()=>t9,eB:()=>d,iy:()=>t8,nB:()=>j});class u{constructor(t){void 0===t&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){let t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){let t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){let e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){void 0===t&&(t=new d);let e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){void 0===e&&(e=new d);let i=this.elements,s=t.x,n=t.y,o=t.z;return e.x=i[0]*s+i[1]*n+i[2]*o,e.y=i[3]*s+i[4]*n+i[5]*o,e.z=i[6]*s+i[7]*n+i[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){void 0===e&&(e=new u);let i=this.elements,s=t.elements,n=e.elements,o=i[0],r=i[1],l=i[2],a=i[3],h=i[4],c=i[5],d=i[6],p=i[7],y=i[8],v=s[0],m=s[1],w=s[2],f=s[3],g=s[4],x=s[5],b=s[6],E=s[7],z=s[8];return n[0]=o*v+r*f+l*b,n[1]=o*m+r*g+l*E,n[2]=o*w+r*x+l*z,n[3]=a*v+h*f+c*b,n[4]=a*m+h*g+c*E,n[5]=a*w+h*x+c*z,n[6]=d*v+p*f+y*b,n[7]=d*m+p*g+y*E,n[8]=d*w+p*x+y*z,e}scale(t,e){void 0===e&&(e=new u);let i=this.elements,s=e.elements;for(let e=0;3!==e;e++)s[3*e+0]=t.x*i[3*e+0],s[3*e+1]=t.y*i[3*e+1],s[3*e+2]=t.z*i[3*e+2];return e}solve(t,e){let i,s,n,o;void 0===e&&(e=new d);let r=[];for(i=0;i<12;i++)r.push(0);for(i=0;i<3;i++)for(s=0;s<3;s++)r[i+4*s]=this.elements[i+3*s];r[3]=t.x,r[7]=t.y,r[11]=t.z;let l=3;do{if(0===r[(i=3-l)+4*i]){for(s=i+1;s<3;s++)if(0!==r[i+4*s]){n=4;do o=4-n,r[o+4*i]+=r[o+4*s];while(--n);break}}if(0!==r[i+4*i])for(s=i+1;s<3;s++){let t=r[i+4*s]/r[i+4*i];n=4;do r[(o=4-n)+4*s]=o<=i?0:r[o+4*s]-r[o+4*i]*t;while(--n)}}while(--l);if(e.z=r[11]/r[10],e.y=(r[7]-r[6]*e.z)/r[5],e.x=(r[3]-r[2]*e.z-r[1]*e.y)/r[0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,i){if(void 0===i)return this.elements[e+3*t];this.elements[e+3*t]=i}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";for(let e=0;e<9;e++)t+=this.elements[e]+",";return t}reverse(t){let e,i,s,n;for(void 0===t&&(t=new u),e=0;e<3;e++)for(i=0;i<3;i++)c[e+6*i]=this.elements[e+3*i];c[3]=1,c[9]=0,c[15]=0,c[4]=0,c[10]=1,c[16]=0,c[5]=0,c[11]=0,c[17]=1;let o=3;do{if(0===c[(e=3-o)+6*e]){for(i=e+1;i<3;i++)if(0!==c[e+6*i]){s=6;do n=6-s,c[n+6*e]+=c[n+6*i];while(--s);break}}if(0!==c[e+6*e])for(i=e+1;i<3;i++){let t=c[e+6*i]/c[e+6*e];s=6;do c[(n=6-s)+6*i]=n<=e?0:c[n+6*i]-c[n+6*e]*t;while(--s)}}while(--o);e=2;do{i=e-1;do{let t=c[e+6*i]/c[e+6*e];s=6;do c[(n=6-s)+6*i]=c[n+6*i]-c[n+6*e]*t;while(--s)}while(i--)}while(--e);e=2;do{let t=1/c[e+6*e];s=6;do c[(n=6-s)+6*e]=c[n+6*e]*t;while(--s)}while(e--);e=2;do{i=2;do{if(isNaN(n=c[3+i+6*e])||n===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(e,i,n)}while(i--)}while(e--);return t}setRotationFromQuaternion(t){let e=t.x,i=t.y,s=t.z,n=t.w,o=e+e,r=i+i,l=s+s,a=e*o,h=e*r,u=e*l,c=i*r,d=i*l,p=s*l,y=n*o,v=n*r,m=n*l,w=this.elements;return w[0]=1-(c+p),w[1]=h-m,w[2]=u+v,w[3]=h+m,w[4]=1-(a+p),w[5]=d-y,w[6]=u-v,w[7]=d+y,w[8]=1-(a+c),this}transpose(t){let e;void 0===t&&(t=new u);let i=this.elements,s=t.elements;return s[0]=i[0],s[4]=i[4],s[8]=i[8],e=i[1],s[1]=i[3],s[3]=e,e=i[2],s[2]=i[6],s[6]=e,e=i[5],s[5]=i[7],s[7]=e,t}}let c=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class d{constructor(t,e,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),this.x=t,this.y=e,this.z=i}cross(t,e){void 0===e&&(e=new d);let i=t.x,s=t.y,n=t.z,o=this.x,r=this.y,l=this.z;return e.x=r*n-l*s,e.y=l*i-o*n,e.z=o*s-r*i,e}set(t,e,i){return this.x=t,this.y=e,this.z=i,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(!e)return new d(this.x+t.x,this.y+t.y,this.z+t.z);e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z}vsub(t,e){if(!e)return new d(this.x-t.x,this.y-t.y,this.z-t.z);e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z}crossmat(){return new u([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){let t=this.x,e=this.y,i=this.z,s=Math.sqrt(t*t+e*e+i*i);if(s>0){let t=1/s;this.x*=t,this.y*=t,this.z*=t}else this.x=0,this.y=0,this.z=0;return s}unit(t){void 0===t&&(t=new d);let e=this.x,i=this.y,s=this.z,n=Math.sqrt(e*e+i*i+s*s);return n>0?(n=1/n,t.x=e*n,t.y=i*n,t.z=s*n):(t.x=1,t.y=0,t.z=0),t}length(){let t=this.x,e=this.y,i=this.z;return Math.sqrt(t*t+e*e+i*i)}lengthSquared(){return this.dot(this)}distanceTo(t){let e=this.x,i=this.y,s=this.z,n=t.x,o=t.y,r=t.z;return Math.sqrt((n-e)*(n-e)+(o-i)*(o-i)+(r-s)*(r-s))}distanceSquared(t){let e=this.x,i=this.y,s=this.z,n=t.x,o=t.y,r=t.z;return(n-e)*(n-e)+(o-i)*(o-i)+(r-s)*(r-s)}scale(t,e){void 0===e&&(e=new d);let i=this.x,s=this.y,n=this.z;return e.x=t*i,e.y=t*s,e.z=t*n,e}vmul(t,e){return void 0===e&&(e=new d),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,i){return void 0===i&&(i=new d),i.x=this.x+t*e.x,i.y=this.y+t*e.y,i.z=this.z+t*e.z,i}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(t){return void 0===t&&(t=new d),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){let i=this.length();if(i>0){let s=1/i;p.set(this.x*s,this.y*s,this.z*s),.9>Math.abs(p.x)?y.set(1,0,0):y.set(0,1,0),p.cross(y,t),p.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,i){let s=this.x,n=this.y,o=this.z;i.x=s+(t.x-s)*e,i.y=n+(t.y-n)*e,i.z=o+(t.z-o)*e}almostEquals(t,e){return void 0===e&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return void 0===t&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(v),v.almostEquals(t,e)}clone(){return new d(this.x,this.y,this.z)}}d.ZERO=new d(0,0,0),d.UNIT_X=new d(1,0,0),d.UNIT_Y=new d(0,1,0),d.UNIT_Z=new d(0,0,1);let p=new d,y=new d,v=new d;class m{constructor(t){void 0===t&&(t={}),this.lowerBound=new d,this.upperBound=new d,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,i,s){let n=this.lowerBound,o=this.upperBound;n.copy(t[0]),i&&i.vmult(n,n),o.copy(n);for(let e=1;e<t.length;e++){let s=t[e];i&&(i.vmult(s,w),s=w),s.x>o.x&&(o.x=s.x),s.x<n.x&&(n.x=s.x),s.y>o.y&&(o.y=s.y),s.y<n.y&&(n.y=s.y),s.z>o.z&&(o.z=s.z),s.z<n.z&&(n.z=s.z)}return e&&(e.vadd(n,n),e.vadd(o,o)),s&&(n.x-=s,n.y-=s,n.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new m().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){let e=this.lowerBound,i=this.upperBound,s=t.lowerBound,n=t.upperBound,o=s.x<=i.x&&i.x<=n.x||e.x<=n.x&&n.x<=i.x,r=s.y<=i.y&&i.y<=n.y||e.y<=n.y&&n.y<=i.y,l=s.z<=i.z&&i.z<=n.z||e.z<=n.z&&n.z<=i.z;return o&&r&&l}volume(){let t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){let e=this.lowerBound,i=this.upperBound,s=t.lowerBound,n=t.upperBound;return e.x<=s.x&&i.x>=n.x&&e.y<=s.y&&i.y>=n.y&&e.z<=s.z&&i.z>=n.z}getCorners(t,e,i,s,n,o,r,l){let a=this.lowerBound,h=this.upperBound;t.copy(a),e.set(h.x,a.y,a.z),i.set(h.x,h.y,a.z),s.set(a.x,h.y,h.z),n.set(h.x,a.y,h.z),o.set(a.x,h.y,a.z),r.set(a.x,a.y,h.z),l.copy(h)}toLocalFrame(t,e){let i=f[0],s=f[1],n=f[2],o=f[3],r=f[4],l=f[5],a=f[6],h=f[7];this.getCorners(i,s,n,o,r,l,a,h);for(let e=0;8!==e;e++){let i=f[e];t.pointToLocal(i,i)}return e.setFromPoints(f)}toWorldFrame(t,e){let i=f[0],s=f[1],n=f[2],o=f[3],r=f[4],l=f[5],a=f[6],h=f[7];this.getCorners(i,s,n,o,r,l,a,h);for(let e=0;8!==e;e++){let i=f[e];t.pointToWorld(i,i)}return e.setFromPoints(f)}overlapsRay(t){let{direction:e,from:i}=t,s=1/e.x,n=1/e.y,o=1/e.z,r=(this.lowerBound.x-i.x)*s,l=(this.upperBound.x-i.x)*s,a=(this.lowerBound.y-i.y)*n,h=(this.upperBound.y-i.y)*n,u=(this.lowerBound.z-i.z)*o,c=(this.upperBound.z-i.z)*o,d=Math.max(Math.max(Math.min(r,l),Math.min(a,h)),Math.min(u,c)),p=Math.min(Math.min(Math.max(r,l),Math.max(a,h)),Math.max(u,c));return!(p<0)&&!(d>p)}}let w=new d,f=[new d,new d,new d,new d,new d,new d,new d,new d];class g{constructor(){this.matrix=[]}get(t,e){let{index:i}=t,{index:s}=e;if(s>i){let t=s;s=i,i=t}return this.matrix[(i*(i+1)>>1)+s-1]}set(t,e,i){let{index:s}=t,{index:n}=e;if(n>s){let t=n;n=s,s=t}this.matrix[(s*(s+1)>>1)+n-1]=+!!i}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class x{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});let i=this._listeners;return void 0===i[t]&&(i[t]=[]),i[t].includes(e)||i[t].push(e),this}hasEventListener(t,e){if(void 0===this._listeners)return!1;let i=this._listeners;return!!(void 0!==i[t]&&i[t].includes(e))}hasAnyEventListener(t){return void 0!==this._listeners&&void 0!==this._listeners[t]}removeEventListener(t,e){if(void 0===this._listeners)return this;let i=this._listeners;if(void 0===i[t])return this;let s=i[t].indexOf(e);return -1!==s&&i[t].splice(s,1),this}dispatchEvent(t){if(void 0===this._listeners)return this;let e=this._listeners[t.type];if(void 0!==e){t.target=this;for(let i=0,s=e.length;i<s;i++)e[i].call(this,t)}return this}}class b{constructor(t,e,i,s){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=1),this.x=t,this.y=e,this.z=i,this.w=s}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){let i=Math.sin(.5*e);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(.5*e),this}toAxisAngle(t){void 0===t&&(t=new d),this.normalize();let e=2*Math.acos(this.w),i=Math.sqrt(1-this.w*this.w);return i<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/i,t.y=this.y/i,t.z=this.z/i),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e))t.tangents(E,z),this.setFromAxisAngle(E,Math.PI);else{let i=t.cross(e);this.x=i.x,this.y=i.y,this.z=i.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){void 0===e&&(e=new b);let i=this.x,s=this.y,n=this.z,o=this.w,r=t.x,l=t.y,a=t.z,h=t.w;return e.x=i*h+o*r+s*a-n*l,e.y=s*h+o*l+n*r-i*a,e.z=n*h+o*a+i*l-s*r,e.w=o*h-i*r-s*l-n*a,e}inverse(t){void 0===t&&(t=new b);let e=this.x,i=this.y,s=this.z,n=this.w;this.conjugate(t);let o=1/(e*e+i*i+s*s+n*n);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return void 0===t&&(t=new b),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){let t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){void 0===e&&(e=new d);let i=t.x,s=t.y,n=t.z,o=this.x,r=this.y,l=this.z,a=this.w,h=a*i+r*n-l*s,u=a*s+l*i-o*n,c=a*n+o*s-r*i,p=-o*i-r*s-l*n;return e.x=h*a+-(p*o)+-(u*l)- -(c*r),e.y=u*a+-(p*r)+-(c*o)- -(h*l),e.z=c*a+-(p*l)+-(h*r)- -(u*o),e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){let i,s,n;void 0===e&&(e="YZX");let o=this.x,r=this.y,l=this.z,a=this.w;if("YZX"===e){let t=o*r+l*a;if(t>.499&&(i=2*Math.atan2(o,a),s=Math.PI/2,n=0),t<-.499&&(i=-2*Math.atan2(o,a),s=-Math.PI/2,n=0),void 0===i){let e=l*l;i=Math.atan2(2*r*a-2*o*l,1-r*r*2-2*e),s=Math.asin(2*t),n=Math.atan2(2*o*a-2*r*l,1-o*o*2-2*e)}}else throw Error(`Euler order ${e} not supported yet.`);t.y=i,t.z=s,t.x=n}setFromEuler(t,e,i,s){void 0===s&&(s="XYZ");let n=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(i/2),l=Math.sin(t/2),a=Math.sin(e/2),h=Math.sin(i/2);return"XYZ"===s?(this.x=l*o*r+n*a*h,this.y=n*a*r-l*o*h,this.z=n*o*h+l*a*r,this.w=n*o*r-l*a*h):"YXZ"===s?(this.x=l*o*r+n*a*h,this.y=n*a*r-l*o*h,this.z=n*o*h-l*a*r,this.w=n*o*r+l*a*h):"ZXY"===s?(this.x=l*o*r-n*a*h,this.y=n*a*r+l*o*h,this.z=n*o*h+l*a*r,this.w=n*o*r-l*a*h):"ZYX"===s?(this.x=l*o*r-n*a*h,this.y=n*a*r+l*o*h,this.z=n*o*h-l*a*r,this.w=n*o*r+l*a*h):"YZX"===s?(this.x=l*o*r+n*a*h,this.y=n*a*r+l*o*h,this.z=n*o*h-l*a*r,this.w=n*o*r-l*a*h):"XZY"===s&&(this.x=l*o*r-n*a*h,this.y=n*a*r-l*o*h,this.z=n*o*h+l*a*r,this.w=n*o*r+l*a*h),this}clone(){return new b(this.x,this.y,this.z,this.w)}slerp(t,e,i){let s,n,o,r,l;void 0===i&&(i=new b);let a=this.x,h=this.y,u=this.z,c=this.w,d=t.x,p=t.y,y=t.z,v=t.w;return(n=a*d+h*p+u*y+c*v)<0&&(n=-n,d=-d,p=-p,y=-y,v=-v),1-n>1e-6?(o=Math.sin(s=Math.acos(n)),r=Math.sin((1-e)*s)/o,l=Math.sin(e*s)/o):(r=1-e,l=e),i.x=r*a+l*d,i.y=r*h+l*p,i.z=r*u+l*y,i.w=r*c+l*v,i}integrate(t,e,i,s){void 0===s&&(s=new b);let n=t.x*i.x,o=t.y*i.y,r=t.z*i.z,l=this.x,a=this.y,h=this.z,u=this.w,c=.5*e;return s.x+=c*(n*u+o*h-r*a),s.y+=c*(o*u+r*l-n*h),s.z+=c*(r*u+n*a-o*l),s.w+=c*(-n*l-o*a-r*h),s}}let E=new d,z=new d;class S{constructor(t){void 0===t&&(t={}),this.id=S.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=!t.collisionResponse||t.collisionResponse,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,i,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}S.idCounter=0,S.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class C{constructor(t){void 0===t&&(t={}),this.position=new d,this.quaternion=new b,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return C.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return C.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return void 0===e&&(e=new d),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,i,s){return void 0===s&&(s=new d),i.vsub(t,s),e.conjugate(A),A.vmult(s,s),s}static pointToWorldFrame(t,e,i,s){return void 0===s&&(s=new d),e.vmult(i,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,i){return void 0===i&&(i=new d),t.vmult(e,i),i}static vectorToLocalFrame(t,e,i,s){return void 0===s&&(s=new d),e.w*=-1,e.vmult(i,s),e.w*=-1,s}}let A=new b;class B extends S{constructor(t){void 0===t&&(t={});let{vertices:e=[],faces:i=[],normals:s=[],axes:n,boundingSphereRadius:o}=t;super({type:S.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=i,this.faceNormals=s,0===this.faceNormals.length&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=n?n.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){let t=this.faces,e=this.vertices,i=this.uniqueEdges;i.length=0;let s=new d;for(let n=0;n!==t.length;n++){let o=t[n],r=o.length;for(let t=0;t!==r;t++){let n=(t+1)%r;e[o[t]].vsub(e[o[n]],s),s.normalize();let l=!1;for(let t=0;t!==i.length;t++)if(i[t].almostEquals(s)||i[t].almostEquals(s)){l=!0;break}l||i.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let e=0;e<this.faces[t].length;e++)if(!this.vertices[this.faces[t][e]])throw Error(`Vertex ${this.faces[t][e]} not found!`);let e=this.faceNormals[t]||new d;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;let i=this.vertices[this.faces[t][0]];if(0>e.dot(i)){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let e=0;e<this.faces[t].length;e++)console.warn(`.vertices[${this.faces[t][e]}] = Vec3(${this.vertices[this.faces[t][e]].toString()})`)}}}getFaceNormal(t,e){let i=this.faces[t],s=this.vertices[i[0]],n=this.vertices[i[1]],o=this.vertices[i[2]];B.computeNormal(s,n,o,e)}static computeNormal(t,e,i,s){let n=new d,o=new d;e.vsub(t,o),i.vsub(e,n),n.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,i,s,n,o,r,l,a){let h=new d,u=-1,c=-Number.MAX_VALUE;for(let t=0;t<i.faces.length;t++){h.copy(i.faceNormals[t]),n.vmult(h,h);let e=h.dot(o);e>c&&(c=e,u=t)}let p=[];for(let t=0;t<i.faces[u].length;t++){let e=i.vertices[i.faces[u][t]],o=new d;o.copy(e),n.vmult(o,o),s.vadd(o,o),p.push(o)}u>=0&&this.clipFaceAgainstHull(o,t,e,p,r,l,a)}findSeparatingAxis(t,e,i,s,n,o,r,l){let a=new d,h=new d,u=new d,c=new d,p=new d,y=new d,v=Number.MAX_VALUE;if(this.uniqueAxes)for(let r=0;r!==this.uniqueAxes.length;r++){i.vmult(this.uniqueAxes[r],a);let l=this.testSepAxis(a,t,e,i,s,n);if(!1===l)return!1;l<v&&(v=l,o.copy(a))}else{let l=r?r.length:this.faces.length;for(let h=0;h<l;h++){let l=r?r[h]:h;a.copy(this.faceNormals[l]),i.vmult(a,a);let u=this.testSepAxis(a,t,e,i,s,n);if(!1===u)return!1;u<v&&(v=u,o.copy(a))}}if(t.uniqueAxes)for(let r=0;r!==t.uniqueAxes.length;r++){n.vmult(t.uniqueAxes[r],h);let l=this.testSepAxis(h,t,e,i,s,n);if(!1===l)return!1;l<v&&(v=l,o.copy(h))}else{let r=l?l.length:t.faces.length;for(let a=0;a<r;a++){let r=l?l[a]:a;h.copy(t.faceNormals[r]),n.vmult(h,h);let u=this.testSepAxis(h,t,e,i,s,n);if(!1===u)return!1;u<v&&(v=u,o.copy(h))}}for(let r=0;r!==this.uniqueEdges.length;r++){i.vmult(this.uniqueEdges[r],c);for(let r=0;r!==t.uniqueEdges.length;r++)if(n.vmult(t.uniqueEdges[r],p),c.cross(p,y),!y.almostZero()){y.normalize();let r=this.testSepAxis(y,t,e,i,s,n);if(!1===r)return!1;r<v&&(v=r,o.copy(y))}}return s.vsub(e,u),u.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,i,s,n,o){B.project(this,t,i,s,M),B.project(e,t,n,o,F);let r=M[0],l=M[1],a=F[0],h=F[1];if(r<h||a<l)return!1;let u=r-h,c=a-l;return u<c?u:c}calculateLocalInertia(t,e){let i=new d,s=new d;this.computeLocalAABB(s,i);let n=i.x-s.x,o=i.y-s.y,r=i.z-s.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*n*2*n+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*n*2*n)}getPlaneConstantOfFace(t){let e=this.faces[t],i=this.faceNormals[t],s=this.vertices[e[0]];return-i.dot(s)}clipFaceAgainstHull(t,e,i,s,n,o,r){let l=new d,a=new d,h=new d,u=new d,c=new d,p=new d,y=new d,v=new d,m=[],w=-1,f=Number.MAX_VALUE;for(let e=0;e<this.faces.length;e++){l.copy(this.faceNormals[e]),i.vmult(l,l);let s=l.dot(t);s<f&&(f=s,w=e)}if(w<0)return;let g=this.faces[w];g.connectedFaces=[];for(let t=0;t<this.faces.length;t++)for(let e=0;e<this.faces[t].length;e++)-1!==g.indexOf(this.faces[t][e])&&t!==w&&-1===g.connectedFaces.indexOf(t)&&g.connectedFaces.push(t);let x=g.length;for(let t=0;t<x;t++){let n=this.vertices[g[t]],o=this.vertices[g[(t+1)%x]];n.vsub(o,a),h.copy(a),i.vmult(h,h),e.vadd(h,h),u.copy(this.faceNormals[w]),i.vmult(u,u),e.vadd(u,u),h.cross(u,c),c.negate(c),p.copy(n),i.vmult(p,p),e.vadd(p,p);let r=g.connectedFaces[t];y.copy(this.faceNormals[r]);let l=this.getPlaneConstantOfFace(r);v.copy(y),i.vmult(v,v);let d=l-v.dot(e);for(this.clipFaceAgainstPlane(s,m,v,d);s.length;)s.shift();for(;m.length;)s.push(m.shift())}y.copy(this.faceNormals[w]);let b=this.getPlaneConstantOfFace(w);v.copy(y),i.vmult(v,v);let E=b-v.dot(e);for(let t=0;t<s.length;t++){let e=v.dot(s[t])+E;if(e<=n&&(console.log(`clamped: depth=${e} to minDist=${n}`),e=n),e<=o){let i=s[t];if(e<=1e-6){let t={point:i,normal:v,depth:e};r.push(t)}}}}clipFaceAgainstPlane(t,e,i,s){let n,o;let r=t.length;if(r<2)return e;let l=t[t.length-1],a=t[0];n=i.dot(l)+s;for(let h=0;h<r;h++){if(a=t[h],o=i.dot(a)+s,n<0){if(o<0){let t=new d;t.copy(a),e.push(t)}else{let t=new d;l.lerp(a,n/(n-o),t),e.push(t)}}else if(o<0){let t=new d;l.lerp(a,n/(n-o),t),e.push(t),e.push(a)}l=a,n=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new d);let i=this.vertices,s=this.worldVertices;for(let n=0;n!==this.vertices.length;n++)e.vmult(i[n],s[n]),t.vadd(s[n],s[n]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){let i=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){let n=i[s];n.x<t.x?t.x=n.x:n.x>e.x&&(e.x=n.x),n.y<t.y?t.y=n.y:n.y>e.y&&(e.y=n.y),n.z<t.z?t.z=n.z:n.z>e.z&&(e.z=n.z)}}computeWorldFaceNormals(t){let e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new d);let i=this.faceNormals,s=this.worldFaceNormals;for(let n=0;n!==e;n++)t.vmult(i[n],s[n]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0,e=this.vertices;for(let i=0;i!==e.length;i++){let s=e[i].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,i,s){let n,o,r,l,a,h;let u=this.vertices,c=new d;for(let i=0;i<u.length;i++)c.copy(u[i]),e.vmult(c,c),t.vadd(c,c),(void 0===n||c.x<n)&&(n=c.x),(void 0===l||c.x>l)&&(l=c.x),(void 0===o||c.y<o)&&(o=c.y),(void 0===a||c.y>a)&&(a=c.y),(void 0===r||c.z<r)&&(r=c.z),(void 0===h||c.z>h)&&(h=c.z);i.set(n,o,r),s.set(l,a,h)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){void 0===t&&(t=new d);let e=this.vertices;for(let i=0;i<e.length;i++)t.vadd(e[i],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){let i=this.vertices.length,s=this.vertices;if(e){for(let t=0;t<i;t++){let i=s[t];e.vmult(i,i)}for(let t=0;t<this.faceNormals.length;t++){let i=this.faceNormals[t];e.vmult(i,i)}}if(t)for(let e=0;e<i;e++){let i=s[e];i.vadd(t,i)}}pointIsInside(t){let e=this.vertices,i=this.faces,s=this.faceNormals,n=new d;this.getAveragePointLocal(n);for(let o=0;o<this.faces.length;o++){let r=s[o],l=e[i[o][0]],a=new d;t.vsub(l,a);let h=r.dot(a),u=new d;n.vsub(l,u);let c=r.dot(u);if(h<0&&c>0||h>0&&c<0)return!1}return -1}static project(t,e,i,s,n){let o=t.vertices.length,r=0,l=0,a=t.vertices;q.setZero(),C.vectorToLocalFrame(i,s,e,N),C.pointToLocalFrame(i,s,q,q);let h=q.dot(N);l=r=a[0].dot(N);for(let t=1;t<o;t++){let e=a[t].dot(N);e>r&&(r=e),e<l&&(l=e)}if((l-=h)>(r-=h)){let t=l;l=r,r=t}n[0]=r,n[1]=l}}let M=[],F=[];new d;let N=new d,q=new d;class R extends S{constructor(t){super({type:S.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){let t=this.halfExtents.x,e=this.halfExtents.y,i=this.halfExtents.z,s=new B({vertices:[new d(-t,-e,-i),new d(t,-e,-i),new d(t,e,-i),new d(-t,e,-i),new d(-t,-e,i),new d(t,-e,i),new d(t,e,i),new d(-t,e,i)],faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:[new d(0,0,1),new d(0,1,0),new d(1,0,0)]});this.convexPolyhedronRepresentation=s,s.material=this.material}calculateLocalInertia(t,e){return void 0===e&&(e=new d),R.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,i){i.x=1/12*e*(2*t.y*2*t.y+2*t.z*2*t.z),i.y=1/12*e*(2*t.x*2*t.x+2*t.z*2*t.z),i.z=1/12*e*(2*t.y*2*t.y+2*t.x*2*t.x)}getSideNormals(t,e){let i=this.halfExtents;if(t[0].set(i.x,0,0),t[1].set(0,i.y,0),t[2].set(0,0,i.z),t[3].set(-i.x,0,0),t[4].set(0,-i.y,0),t[5].set(0,0,-i.z),void 0!==e)for(let i=0;i!==t.length;i++)e.vmult(t[i],t[i]);return t}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,i){let s=this.halfExtents,n=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let s=0;s<n.length;s++)P.set(n[s][0],n[s][1],n[s][2]),e.vmult(P,P),t.vadd(P,P),i(P.x,P.y,P.z)}calculateWorldAABB(t,e,i,s){let n=this.halfExtents;T[0].set(n.x,n.y,n.z),T[1].set(-n.x,n.y,n.z),T[2].set(-n.x,-n.y,n.z),T[3].set(-n.x,-n.y,-n.z),T[4].set(n.x,-n.y,-n.z),T[5].set(n.x,n.y,-n.z),T[6].set(-n.x,n.y,-n.z),T[7].set(n.x,-n.y,n.z);let o=T[0];e.vmult(o,o),t.vadd(o,o),s.copy(o),i.copy(o);for(let n=1;n<8;n++){let o=T[n];e.vmult(o,o),t.vadd(o,o);let r=o.x,l=o.y,a=o.z;r>s.x&&(s.x=r),l>s.y&&(s.y=l),a>s.z&&(s.z=a),r<i.x&&(i.x=r),l<i.y&&(i.y=l),a<i.z&&(i.z=a)}}}let P=new d,T=[new d,new d,new d,new d,new d,new d,new d,new d],I={DYNAMIC:1,STATIC:2,KINEMATIC:4},L={AWAKE:0,SLEEPY:1,SLEEPING:2};class j extends x{constructor(t){void 0===t&&(t={}),super(),this.id=j.idCounter++,this.index=-1,this.world=null,this.vlambda=new d,this.collisionFilterGroup="number"==typeof t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof t.collisionResponse||t.collisionResponse,this.position=new d,this.previousPosition=new d,this.interpolatedPosition=new d,this.initPosition=new d,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new d,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new d,this.force=new d;let e="number"==typeof t.mass?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping="number"==typeof t.linearDamping?t.linearDamping:.01,this.type=e<=0?j.STATIC:j.DYNAMIC,typeof t.type==typeof j.STATIC&&(this.type=t.type),this.allowSleep=void 0===t.allowSleep||t.allowSleep,this.sleepState=j.AWAKE,this.sleepSpeedLimit=void 0!==t.sleepSpeedLimit?t.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==t.sleepTimeLimit?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new d,this.quaternion=new b,this.initQuaternion=new b,this.previousQuaternion=new b,this.interpolatedQuaternion=new b,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new d,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new d,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new d,this.invInertia=new d,this.invInertiaWorld=new u,this.invMassSolve=0,this.invInertiaSolve=new d,this.invInertiaWorldSolve=new u,this.fixedRotation=void 0!==t.fixedRotation&&t.fixedRotation,this.angularDamping=void 0!==t.angularDamping?t.angularDamping:.01,this.linearFactor=new d(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new d(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new m,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new d,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){let t=this.sleepState;this.sleepState=j.AWAKE,this.wakeUpAfterNarrowphase=!1,t===j.SLEEPING&&this.dispatchEvent(j.wakeupEvent)}sleep(){this.sleepState=j.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){let e=this.sleepState,i=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===j.AWAKE&&i<s?(this.sleepState=j.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(j.sleepyEvent)):e===j.SLEEPY&&i>s?this.wakeUp():e===j.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(j.sleepEvent))}}updateSolveMassProperties(){this.sleepState===j.SLEEPING||this.type===j.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return void 0===e&&(e=new d),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return void 0===e&&(e=new d),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return void 0===e&&(e=new d),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return void 0===e&&(e=new d),this.quaternion.vmult(t,e),e}addShape(t,e,i){let s=new d,n=new b;return e&&s.copy(e),i&&n.copy(i),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(n),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){let e=this.shapes.indexOf(t);return -1===e?console.warn("Shape does not belong to the body"):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null),this}updateBoundingRadius(){let t=this.shapes,e=this.shapeOffsets,i=t.length,s=0;for(let n=0;n!==i;n++){let i=t[n];i.updateBoundingSphereRadius();let o=e[n].length(),r=i.boundingSphereRadius;o+r>s&&(s=o+r)}this.boundingRadius=s}updateAABB(){let t=this.shapes,e=this.shapeOffsets,i=this.shapeOrientations,s=t.length,n=this.quaternion,o=this.aabb;for(let r=0;r!==s;r++){let s=t[r];n.vmult(e[r],O),O.vadd(this.position,O),n.mult(i[r],k),s.calculateWorldAABB(O,k,W.lowerBound,W.upperBound),0===r?o.copy(W):o.extend(W)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){let e=this.invInertia;(e.x!==e.y||e.y!==e.z||t)&&(V.setRotationFromQuaternion(this.quaternion),V.transpose(H),V.scale(e,V),V.mmult(H,this.invInertiaWorld))}applyForce(t,e){void 0===e&&(e=new d),this.type===j.DYNAMIC&&(this.sleepState===j.SLEEPING&&this.wakeUp(),e.cross(t,D),this.force.vadd(t,this.force),this.torque.vadd(D,this.torque))}applyLocalForce(t,e){void 0===e&&(e=new d),this.type===j.DYNAMIC&&(this.vectorToWorldFrame(t,G),this.vectorToWorldFrame(e,Y),this.applyForce(G,Y))}applyTorque(t){this.type===j.DYNAMIC&&(this.sleepState===j.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(void 0===e&&(e=new d),this.type!==j.DYNAMIC)return;this.sleepState===j.SLEEPING&&this.wakeUp();let i=e;_.copy(t),_.scale(this.invMass,_),this.velocity.vadd(_,this.velocity),i.cross(t,U),this.invInertiaWorld.vmult(U,U),this.angularVelocity.vadd(U,this.angularVelocity)}applyLocalImpulse(t,e){void 0===e&&(e=new d),this.type===j.DYNAMIC&&(this.vectorToWorldFrame(t,X),this.vectorToWorldFrame(e,$),this.applyImpulse(X,$))}updateMassProperties(){this.invMass=this.mass>0?1/this.mass:0;let t=this.inertia,e=this.fixedRotation;this.updateAABB(),K.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),R.calculateInertia(K,this.mass,t),this.invInertia.set(t.x>0&&!e?1/t.x:0,t.y>0&&!e?1/t.y:0,t.z>0&&!e?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){let i=new d;return t.vsub(this.position,i),this.angularVelocity.cross(i,e),this.velocity.vadd(e,e),e}integrate(t,e,i){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==j.DYNAMIC&&this.type!==j.KINEMATIC||this.sleepState===j.SLEEPING)return;let s=this.velocity,n=this.angularVelocity,o=this.position,r=this.force,l=this.torque,a=this.quaternion,h=this.invMass,u=this.invInertiaWorld,c=this.linearFactor,d=h*t;s.x+=r.x*d*c.x,s.y+=r.y*d*c.y,s.z+=r.z*d*c.z;let p=u.elements,y=this.angularFactor,v=l.x*y.x,m=l.y*y.y,w=l.z*y.z;n.x+=t*(p[0]*v+p[1]*m+p[2]*w),n.y+=t*(p[3]*v+p[4]*m+p[5]*w),n.z+=t*(p[6]*v+p[7]*m+p[8]*w),o.x+=s.x*t,o.y+=s.y*t,o.z+=s.z*t,a.integrate(this.angularVelocity,t,this.angularFactor,a),e&&(i?a.normalizeFast():a.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}j.idCounter=0,j.COLLIDE_EVENT_NAME="collide",j.DYNAMIC=I.DYNAMIC,j.STATIC=I.STATIC,j.KINEMATIC=I.KINEMATIC,j.AWAKE=L.AWAKE,j.SLEEPY=L.SLEEPY,j.SLEEPING=L.SLEEPING,j.wakeupEvent={type:"wakeup"},j.sleepyEvent={type:"sleepy"},j.sleepEvent={type:"sleep"};let O=new d,k=new b,W=new m,V=new u,H=new u;new u;let D=new d,G=new d,Y=new d,_=new d,U=new d,X=new d,$=new d,K=new d;class Z{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,i){throw Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return(t.collisionFilterGroup&e.collisionFilterMask)!=0&&(e.collisionFilterGroup&t.collisionFilterMask)!=0&&((t.type&j.STATIC)==0&&t.sleepState!==j.SLEEPING||(e.type&j.STATIC)==0&&e.sleepState!==j.SLEEPING)}intersectionTest(t,e,i,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,i,s):this.doBoundingSphereBroadphase(t,e,i,s)}doBoundingSphereBroadphase(t,e,i,s){e.position.vsub(t.position,Q);let n=(t.boundingRadius+e.boundingRadius)**2;Q.lengthSquared()<n&&(i.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,i,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(i.push(t),s.push(e))}makePairsUnique(t,e){let i=t.length;for(let s=0;s!==i;s++)tt[s]=t[s],te[s]=e[s];t.length=0,e.length=0;for(let t=0;t!==i;t++){let e=tt[t].id,i=te[t].id,s=e<i?`${e},${i}`:`${i},${e}`;J[s]=t,J.keys.push(s)}for(let i=0;i!==J.keys.length;i++){let i=J.keys.pop(),s=J[i];t.push(tt[s]),e.push(te[s]),delete J[i]}}setWorld(t){}static boundingSphereCheck(t,e){let i=new d;t.position.vsub(e.position,i);let s=t.shapes[0],n=e.shapes[0];return Math.pow(s.boundingSphereRadius+n.boundingSphereRadius,2)>i.lengthSquared()}aabbQuery(t,e,i){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}let Q=new d;new d,new b,new d;let J={keys:[]},tt=[],te=[];new d,new d,new d;class ti extends Z{constructor(){super()}collisionPairs(t,e,i){let s,n;let o=t.bodies,r=o.length;for(let t=0;t!==r;t++)for(let r=0;r!==t;r++)s=o[t],n=o[r],this.needBroadphaseCollision(s,n)&&this.intersectionTest(s,n,e,i)}aabbQuery(t,e,i){void 0===i&&(i=[]);for(let s=0;s<t.bodies.length;s++){let n=t.bodies[s];n.aabbNeedsUpdate&&n.updateAABB(),n.aabb.overlaps(e)&&i.push(n)}return i}}class ts{constructor(){this.rayFromWorld=new d,this.rayToWorld=new d,this.hitNormalWorld=new d,this.hitPointWorld=new d,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,i,s,n,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(i),this.hitPointWorld.copy(s),this.shape=n,this.body=o,this.distance=r}}let tn={CLOSEST:1,ANY:2,ALL:4};s=S.types.SPHERE,n=S.types.PLANE,o=S.types.BOX,r=S.types.CYLINDER,l=S.types.CONVEXPOLYHEDRON,a=S.types.HEIGHTFIELD,h=S.types.TRIMESH;class to{get[s](){return this._intersectSphere}get[n](){return this._intersectPlane}get[o](){return this._intersectBox}get[r](){return this._intersectConvex}get[l](){return this._intersectConvex}get[a](){return this._intersectHeightfield}get[h](){return this._intersectTrimesh}constructor(t,e){void 0===t&&(t=new d),void 0===e&&(e=new d),this.from=t.clone(),this.to=e.clone(),this.direction=new d,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=to.ANY,this.result=new ts,this.hasHit=!1,this.callback=t=>{}}intersectWorld(t,e){return this.mode=e.mode||to.ANY,this.result=e.result||new ts,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===e.checkCollisionResponse||e.checkCollisionResponse,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(tr),tl.length=0,t.broadphase.aabbQuery(t,tr,tl),this.intersectBodies(tl),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());let i=this.checkCollisionResponse;if((!i||t.collisionResponse)&&(this.collisionFilterGroup&t.collisionFilterMask)!=0&&(t.collisionFilterGroup&this.collisionFilterMask)!=0)for(let e=0,s=t.shapes.length;e<s;e++){let s=t.shapes[e];if((!i||s.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[e],tc),t.quaternion.vmult(t.shapeOffsets[e],tu),tu.vadd(t.position,tu),this.intersectShape(s,tc,tu,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let e=0,i=t.length;!this.result.shouldStop&&e<i;e++)this.intersectBody(t[e])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,i,s){if(function(t,e,i){i.vsub(t,tR);let s=tR.dot(e);return e.scale(s,tP),tP.vadd(t,tP),i.distanceTo(tP)}(this.from,this.direction,i)>t.boundingSphereRadius)return;let n=this[t.type];n&&n.call(this,t,e,i,s,t)}_intersectBox(t,e,i,s,n){return this._intersectConvex(t.convexPolyhedronRepresentation,e,i,s,n)}_intersectPlane(t,e,i,s,n){let o=this.from,r=this.to,l=this.direction,a=new d(0,0,1);e.vmult(a,a);let h=new d;o.vsub(i,h);let u=h.dot(a);if(r.vsub(i,h),u*h.dot(a)>0||o.distanceTo(r)<u)return;let c=a.dot(l);if(Math.abs(c)<this.precision)return;let p=new d,y=new d,v=new d;o.vsub(i,p);let m=-a.dot(p)/c;l.scale(m,y),o.vadd(y,v),this.reportIntersection(a,v,n,s,-1)}getAABB(t){let{lowerBound:e,upperBound:i}=t,s=this.to,n=this.from;e.x=Math.min(s.x,n.x),e.y=Math.min(s.y,n.y),e.z=Math.min(s.z,n.z),i.x=Math.max(s.x,n.x),i.y=Math.max(s.y,n.y),i.z=Math.max(s.z,n.z)}_intersectHeightfield(t,e,i,s,n){let o,r,l,a;t.data,t.elementSize,tf.from.copy(this.from),tf.to.copy(this.to),C.pointToLocalFrame(i,e,tf.from,tf.from),C.pointToLocalFrame(i,e,tf.to,tf.to),tf.updateDirection(),o=r=0,l=a=t.data.length-1;let h=new m;tf.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,tg,!0),o=Math.max(o,tg[0]),r=Math.max(r,tg[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,tg,!0),l=Math.min(l,tg[0]+1),a=Math.min(a,tg[1]+1);for(let u=o;u<l;u++)for(let o=r;o<a;o++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(u,o,h),h.overlapsRay(tf)){if(t.getConvexTrianglePillar(u,o,!1),C.pointToWorldFrame(i,e,t.pillarOffset,tw),this._intersectConvex(t.pillarConvex,e,tw,s,n,tm),this.result.shouldStop)return;t.getConvexTrianglePillar(u,o,!0),C.pointToWorldFrame(i,e,t.pillarOffset,tw),this._intersectConvex(t.pillarConvex,e,tw,s,n,tm)}}}_intersectSphere(t,e,i,s,n){let o=this.from,r=this.to,l=t.radius,a=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,h=2*((r.x-o.x)*(o.x-i.x)+(r.y-o.y)*(o.y-i.y)+(r.z-o.z)*(o.z-i.z)),u=h**2-4*a*((o.x-i.x)**2+(o.y-i.y)**2+(o.z-i.z)**2-l**2);if(!(u<0)){if(0===u)o.lerp(r,u,tx),tx.vsub(i,tb),tb.normalize(),this.reportIntersection(tb,tx,n,s,-1);else{let t=(-h-Math.sqrt(u))/(2*a),e=(-h+Math.sqrt(u))/(2*a);if(t>=0&&t<=1&&(o.lerp(r,t,tx),tx.vsub(i,tb),tb.normalize(),this.reportIntersection(tb,tx,n,s,-1)),this.result.shouldStop)return;e>=0&&e<=1&&(o.lerp(r,e,tx),tx.vsub(i,tb),tb.normalize(),this.reportIntersection(tb,tx,n,s,-1))}}}_intersectConvex(t,e,i,s,n,o){let r=o&&o.faceList||null,l=t.faces,a=t.vertices,h=t.faceNormals,u=this.direction,c=this.from,d=this.to,p=c.distanceTo(d),y=r?r.length:l.length,v=this.result;for(let t=0;!v.shouldStop&&t<y;t++){let o=r?r[t]:t,d=l[o],y=h[o];tz.copy(a[d[0]]),e.vmult(tz,tz),tz.vadd(i,tz),tz.vsub(c,tz),e.vmult(y,tE);let m=u.dot(tE);if(Math.abs(m)<this.precision)continue;let w=tE.dot(tz)/m;if(!(w<0)){u.scale(w,td),td.vadd(c,td),tp.copy(a[d[0]]),e.vmult(tp,tp),i.vadd(tp,tp);for(let t=1;!v.shouldStop&&t<d.length-1;t++){ty.copy(a[d[t]]),tv.copy(a[d[t+1]]),e.vmult(ty,ty),e.vmult(tv,tv),i.vadd(ty,ty),i.vadd(tv,tv);let r=td.distanceTo(c);(to.pointInTriangle(td,tp,ty,tv)||to.pointInTriangle(td,ty,tp,tv))&&!(r>p)&&this.reportIntersection(tE,td,n,s,o)}}}}_intersectTrimesh(t,e,i,s,n,o){let r=t.indices;t.vertices;let l=this.from,a=this.to,h=this.direction;tq.position.copy(i),tq.quaternion.copy(e),C.vectorToLocalFrame(i,e,h,tC),C.pointToLocalFrame(i,e,l,tA),C.pointToLocalFrame(i,e,a,tB),tB.x*=t.scale.x,tB.y*=t.scale.y,tB.z*=t.scale.z,tA.x*=t.scale.x,tA.y*=t.scale.y,tA.z*=t.scale.z,tB.vsub(tA,tC),tC.normalize();let u=tA.distanceSquared(tB);t.tree.rayQuery(this,tq,tN);for(let o=0,l=tN.length;!this.result.shouldStop&&o!==l;o++){let l=tN[o];t.getNormal(l,tS),t.getVertex(r[3*l],tp),tp.vsub(tA,tz);let a=tC.dot(tS),h=tS.dot(tz)/a;if(h<0)continue;tC.scale(h,td),td.vadd(tA,td),t.getVertex(r[3*l+1],ty),t.getVertex(r[3*l+2],tv);let c=td.distanceSquared(tA);(to.pointInTriangle(td,ty,tp,tv)||to.pointInTriangle(td,tp,ty,tv))&&!(c>u)&&(C.vectorToWorldFrame(e,tS,tM),C.pointToWorldFrame(i,e,td,tF),this.reportIntersection(tM,tF,n,s,l))}tN.length=0}reportIntersection(t,e,i,s,n){let o=this.from,r=this.to,l=o.distanceTo(e),a=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(a.hitFaceIndex=void 0!==n?n:-1,this.mode){case to.ALL:this.hasHit=!0,a.set(o,r,t,e,i,s,l),a.hasHit=!0,this.callback(a);break;case to.CLOSEST:(l<a.distance||!a.hasHit)&&(this.hasHit=!0,a.hasHit=!0,a.set(o,r,t,e,i,s,l));break;case to.ANY:this.hasHit=!0,a.hasHit=!0,a.set(o,r,t,e,i,s,l),a.shouldStop=!0}}static pointInTriangle(t,e,i,s){let n,o;s.vsub(e,tR),i.vsub(e,ta),t.vsub(e,th);let r=tR.dot(tR),l=tR.dot(ta),a=tR.dot(th),h=ta.dot(ta),u=ta.dot(th);return(n=h*a-l*u)>=0&&(o=r*u-l*a)>=0&&n+o<r*h-l*l}}to.CLOSEST=tn.CLOSEST,to.ANY=tn.ANY,to.ALL=tn.ALL;let tr=new m,tl=[],ta=new d,th=new d,tu=new d,tc=new b,td=new d,tp=new d,ty=new d,tv=new d;new d,new ts;let tm={faceList:[0]},tw=new d,tf=new to,tg=[],tx=new d,tb=new d,tE=new d;new d,new d;let tz=new d,tS=new d,tC=new d,tA=new d,tB=new d,tM=new d,tF=new d;new m;let tN=[],tq=new C,tR=new d,tP=new d;class tT{static defaults(t,e){for(let i in void 0===t&&(t={}),e)i in t||(t[i]=e[i]);return t}}class tI{constructor(t,e,i){void 0===i&&(i={}),i=tT.defaults(i,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=t,this.bodyB=e,this.id=tI.idCounter++,this.collideConnected=i.collideConnected,i.wakeUpBodies&&(t&&t.wakeUp(),e&&e.wakeUp())}update(){throw Error("method update() not implmemented in this Constraint subclass!")}enable(){let t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!0}disable(){let t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!1}}tI.idCounter=0;class tL{constructor(){this.spatial=new d,this.rotational=new d}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class tj{constructor(t,e,i,s){void 0===i&&(i=-1e6),void 0===s&&(s=1e6),this.id=tj.idCounter++,this.minForce=i,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new tL,this.jacobianElementB=new tL,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,i){this.a=4/(i*(1+4*e)),this.b=4*e/(1+4*e),this.eps=4/(i*i*t*(1+4*e))}computeB(t,e,i){let s=this.computeGW();return-this.computeGq()*t-s*e-this.computeGiMf()*i}computeGq(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.position,o=s.position;return t.spatial.dot(n)+e.spatial.dot(o)}computeGW(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.velocity,o=s.velocity,r=i.angularVelocity,l=s.angularVelocity;return t.multiplyVectors(n,r)+e.multiplyVectors(o,l)}computeGWlambda(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.vlambda,o=s.vlambda,r=i.wlambda,l=s.wlambda;return t.multiplyVectors(n,r)+e.multiplyVectors(o,l)}computeGiMf(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.force,o=i.torque,r=s.force,l=s.torque,a=i.invMassSolve,h=s.invMassSolve;return n.scale(a,tO),r.scale(h,tk),i.invInertiaWorldSolve.vmult(o,tW),s.invInertiaWorldSolve.vmult(l,tV),t.multiplyVectors(tO,tW)+e.multiplyVectors(tk,tV)}computeGiMGt(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.invMassSolve,o=s.invMassSolve,r=i.invInertiaWorldSolve,l=s.invInertiaWorldSolve,a=n+o;return r.vmult(t.rotational,tH),a+=tH.dot(t.rotational),l.vmult(e.rotational,tH),a+=tH.dot(e.rotational)}addToWlambda(t){let e=this.jacobianElementA,i=this.jacobianElementB,s=this.bi,n=this.bj;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),n.vlambda.addScaledVector(n.invMassSolve*t,i.spatial,n.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,tD),s.wlambda.addScaledVector(t,tD,s.wlambda),n.invInertiaWorldSolve.vmult(i.rotational,tD),n.wlambda.addScaledVector(t,tD,n.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}tj.idCounter=0;let tO=new d,tk=new d,tW=new d,tV=new d,tH=new d,tD=new d;class tG extends tj{constructor(t,e,i){void 0===i&&(i=1e6),super(t,e,0,i),this.restitution=0,this.ri=new d,this.rj=new d,this.ni=new d}computeB(t){let e=this.a,i=this.b,s=this.bi,n=this.bj,o=this.ri,r=this.rj,l=s.velocity,a=s.angularVelocity;s.force,s.torque;let h=n.velocity,u=n.angularVelocity;n.force,n.torque;let c=this.jacobianElementA,d=this.jacobianElementB,p=this.ni;o.cross(p,tY),r.cross(p,t_),p.negate(c.spatial),tY.negate(c.rotational),d.spatial.copy(p),d.rotational.copy(t_),tU.copy(n.position),tU.vadd(r,tU),tU.vsub(s.position,tU),tU.vsub(o,tU);let y=p.dot(tU),v=this.restitution+1,m=v*h.dot(p)-v*l.dot(p)+u.dot(t_)-a.dot(tY);return-y*e-m*i-t*this.computeGiMf()}getImpactVelocityAlongNormal(){return this.bi.position.vadd(this.ri,tK),this.bj.position.vadd(this.rj,tZ),this.bi.getVelocityAtWorldPoint(tK,tX),this.bj.getVelocityAtWorldPoint(tZ,t$),tX.vsub(t$,tQ),this.ni.dot(tQ)}}let tY=new d,t_=new d,tU=new d,tX=new d,t$=new d,tK=new d,tZ=new d,tQ=new d;new d,new d,new d,new d,new d,new d,new d,new d,new d,new d;class tJ extends tj{constructor(t,e,i){super(t,e,-i,i),this.ri=new d,this.rj=new d,this.t=new d}computeB(t){this.a;let e=this.b;this.bi,this.bj;let i=this.ri,s=this.rj,n=this.t;i.cross(n,t0),s.cross(n,t1);let o=this.jacobianElementA,r=this.jacobianElementB;n.negate(o.spatial),t0.negate(o.rotational),r.spatial.copy(n),r.rotational.copy(t1);let l=this.computeGW();return-l*e-t*this.computeGiMf()}}let t0=new d,t1=new d;class t2{constructor(t,e,i){i=tT.defaults(i,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=t2.idCounter++,this.materials=[t,e],this.friction=i.friction,this.restitution=i.restitution,this.contactEquationStiffness=i.contactEquationStiffness,this.contactEquationRelaxation=i.contactEquationRelaxation,this.frictionEquationStiffness=i.frictionEquationStiffness,this.frictionEquationRelaxation=i.frictionEquationRelaxation}}t2.idCounter=0;class t3{constructor(t){void 0===t&&(t={});let e="";"string"==typeof t&&(e=t,t={}),this.name=e,this.id=t3.idCounter++,this.friction=void 0!==t.friction?t.friction:-1,this.restitution=void 0!==t.restitution?t.restitution:-1}}t3.idCounter=0,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new to,new d,new d,new d,new d(1,0,0),new d(0,1,0),new d(0,0,1),new d,new d,new d,new d;let t6=new d,t4=new d,t5=new d,t7=new d;new d,new d,new d;class t8 extends S{constructor(t){if(super({type:S.types.SPHERE}),this.radius=void 0!==t?t:1,this.radius<0)throw Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(t,e){void 0===e&&(e=new d);let i=2*t*this.radius*this.radius/5;return e.x=i,e.y=i,e.z=i,e}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(t,e,i,s){let n=this.radius,o=["x","y","z"];for(let e=0;e<o.length;e++){let r=o[e];i[r]=t[r]-n,s[r]=t[r]+n}}}new d,new d,new d,new d,new d,new d,new d,new d,new d;class t9 extends S{constructor(){super({type:S.types.PLANE}),this.worldNormal=new d,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){let e=this.worldNormal;e.set(0,0,1),t.vmult(e,e),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,e){return void 0===e&&(e=new d),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,i,s){et.set(0,0,1),e.vmult(et,et);let n=Number.MAX_VALUE;i.set(-n,-n,-n),s.set(n,n,n),1===et.x?s.x=t.x:-1===et.x&&(i.x=t.x),1===et.y?s.y=t.y:-1===et.y&&(i.y=t.y),1===et.z?s.z=t.z:-1===et.z&&(i.z=t.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}let et=new d;new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new m,new d,new m,new d,new d,new d,new d,new d,new d,new d,new m,new d,new C,new m;class ee{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){!t.enabled||t.bi.isTrigger||t.bj.isTrigger||this.equations.push(t)}removeEquation(t){let e=this.equations,i=e.indexOf(t);-1!==i&&e.splice(i,1)}removeAllEquations(){this.equations.length=0}}class ei extends ee{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let i,s,n,o,r,l=0,a=this.iterations,h=this.tolerance*this.tolerance,u=this.equations,c=u.length,d=e.bodies,p=d.length;if(0!==c)for(let t=0;t!==p;t++)d[t].updateSolveMassProperties();en.length=c,eo.length=c,es.length=c;for(let e=0;e!==c;e++){let i=u[e];es[e]=0,eo[e]=i.computeB(t),en[e]=1/i.computeC()}if(0!==c){for(let t=0;t!==p;t++){let e=d[t],i=e.vlambda,s=e.wlambda;i.set(0,0,0),s.set(0,0,0)}for(l=0;l!==a;l++){o=0;for(let t=0;t!==c;t++){let e=u[t];i=eo[t],s=en[t],r=es[t],n=s*(i-e.computeGWlambda()-e.eps*r),r+n<e.minForce?n=e.minForce-r:r+n>e.maxForce&&(n=e.maxForce-r),es[t]+=n,o+=n>0?n:-n,e.addToWlambda(n)}if(o*o<h)break}for(let t=0;t!==p;t++){let e=d[t],i=e.velocity,s=e.angularVelocity;e.vlambda.vmul(e.linearFactor,e.vlambda),i.vadd(e.vlambda,i),e.wlambda.vmul(e.angularFactor,e.wlambda),s.vadd(e.wlambda,s)}let e=u.length,y=1/t;for(;e--;)u[e].multiplier=es[e]*y}return l}}let es=[],en=[],eo=[];j.STATIC;class er{constructor(){this.objects=[],this.type=Object}release(){let t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){let e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class el extends er{constructor(){super(...arguments),this.type=d}constructObject(){return new d}}let ea={sphereSphere:S.types.SPHERE,spherePlane:S.types.SPHERE|S.types.PLANE,boxBox:S.types.BOX|S.types.BOX,sphereBox:S.types.SPHERE|S.types.BOX,planeBox:S.types.PLANE|S.types.BOX,convexConvex:S.types.CONVEXPOLYHEDRON,sphereConvex:S.types.SPHERE|S.types.CONVEXPOLYHEDRON,planeConvex:S.types.PLANE|S.types.CONVEXPOLYHEDRON,boxConvex:S.types.BOX|S.types.CONVEXPOLYHEDRON,sphereHeightfield:S.types.SPHERE|S.types.HEIGHTFIELD,boxHeightfield:S.types.BOX|S.types.HEIGHTFIELD,convexHeightfield:S.types.CONVEXPOLYHEDRON|S.types.HEIGHTFIELD,sphereParticle:S.types.PARTICLE|S.types.SPHERE,planeParticle:S.types.PLANE|S.types.PARTICLE,boxParticle:S.types.BOX|S.types.PARTICLE,convexParticle:S.types.PARTICLE|S.types.CONVEXPOLYHEDRON,cylinderCylinder:S.types.CYLINDER,sphereCylinder:S.types.SPHERE|S.types.CYLINDER,planeCylinder:S.types.PLANE|S.types.CYLINDER,boxCylinder:S.types.BOX|S.types.CYLINDER,convexCylinder:S.types.CONVEXPOLYHEDRON|S.types.CYLINDER,heightfieldCylinder:S.types.HEIGHTFIELD|S.types.CYLINDER,particleCylinder:S.types.PARTICLE|S.types.CYLINDER,sphereTrimesh:S.types.SPHERE|S.types.TRIMESH,planeTrimesh:S.types.PLANE|S.types.TRIMESH};class eh{get[ea.sphereSphere](){return this.sphereSphere}get[ea.spherePlane](){return this.spherePlane}get[ea.boxBox](){return this.boxBox}get[ea.sphereBox](){return this.sphereBox}get[ea.planeBox](){return this.planeBox}get[ea.convexConvex](){return this.convexConvex}get[ea.sphereConvex](){return this.sphereConvex}get[ea.planeConvex](){return this.planeConvex}get[ea.boxConvex](){return this.boxConvex}get[ea.sphereHeightfield](){return this.sphereHeightfield}get[ea.boxHeightfield](){return this.boxHeightfield}get[ea.convexHeightfield](){return this.convexHeightfield}get[ea.sphereParticle](){return this.sphereParticle}get[ea.planeParticle](){return this.planeParticle}get[ea.boxParticle](){return this.boxParticle}get[ea.convexParticle](){return this.convexParticle}get[ea.cylinderCylinder](){return this.convexConvex}get[ea.sphereCylinder](){return this.sphereConvex}get[ea.planeCylinder](){return this.planeConvex}get[ea.boxCylinder](){return this.boxConvex}get[ea.convexCylinder](){return this.convexConvex}get[ea.heightfieldCylinder](){return this.heightfieldCylinder}get[ea.particleCylinder](){return this.particleCylinder}get[ea.sphereTrimesh](){return this.sphereTrimesh}get[ea.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new el,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,i,s,n,o){let r;this.contactPointPool.length?((r=this.contactPointPool.pop()).bi=t,r.bj=e):r=new tG(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&i.collisionResponse&&s.collisionResponse;let l=this.currentContactMaterial;r.restitution=l.restitution,r.setSpookParams(l.contactEquationStiffness,l.contactEquationRelaxation,this.world.dt);let a=i.material||t.material,h=s.material||e.material;return a&&h&&a.restitution>=0&&h.restitution>=0&&(r.restitution=a.restitution*h.restitution),r.si=n||i,r.sj=o||s,r}createFrictionEquationsFromContact(t,e){let i=t.bi,s=t.bj,n=t.si,o=t.sj,r=this.world,l=this.currentContactMaterial,a=l.friction,h=n.material||i.material,u=o.material||s.material;if(h&&u&&h.friction>=0&&u.friction>=0&&(a=h.friction*u.friction),a>0){let n=a*(r.frictionGravity||r.gravity).length(),o=i.invMass+s.invMass;o>0&&(o=1/o);let h=this.frictionEquationPool,u=h.length?h.pop():new tJ(i,s,n*o),c=h.length?h.pop():new tJ(i,s,n*o);return u.bi=c.bi=i,u.bj=c.bj=s,u.minForce=c.minForce=-n*o,u.maxForce=c.maxForce=n*o,u.ri.copy(t.ri),u.rj.copy(t.rj),c.ri.copy(t.ri),c.rj.copy(t.rj),t.ni.tangents(u.t,c.t),u.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),c.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),u.enabled=c.enabled=t.enabled,e.push(u,c),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||1===t)return;let i=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];eu.setZero(),ec.setZero(),ed.setZero();let n=e.bi;e.bj;for(let i=0;i!==t;i++)(e=this.result[this.result.length-1-i]).bi!==n?(eu.vadd(e.ni,eu),ec.vadd(e.ri,ec),ed.vadd(e.rj,ed)):(eu.vsub(e.ni,eu),ec.vadd(e.rj,ec),ed.vadd(e.ri,ed));let o=1/t;ec.scale(o,i.ri),ed.scale(o,i.rj),s.ri.copy(i.ri),s.rj.copy(i.rj),eu.normalize(),eu.tangents(i.t,s.t)}getContacts(t,e,i,s,n,o,r){this.contactPointPool=n,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;for(let s=0,n=t.length;s!==n;s++){let n=t[s],o=e[s],r=null;n.material&&o.material&&(r=i.getContactMaterial(n.material,o.material)||null);let l=n.type&j.KINEMATIC&&o.type&j.STATIC||n.type&j.STATIC&&o.type&j.KINEMATIC||n.type&j.KINEMATIC&&o.type&j.KINEMATIC;for(let t=0;t<n.shapes.length;t++){n.quaternion.mult(n.shapeOrientations[t],ev),n.quaternion.vmult(n.shapeOffsets[t],ep),ep.vadd(n.position,ep);let e=n.shapes[t];for(let t=0;t<o.shapes.length;t++){o.quaternion.mult(o.shapeOrientations[t],em),o.quaternion.vmult(o.shapeOffsets[t],ey),ey.vadd(o.position,ey);let s=o.shapes[t];if(!(e.collisionFilterMask&s.collisionFilterGroup&&s.collisionFilterMask&e.collisionFilterGroup)||ep.distanceTo(ey)>e.boundingSphereRadius+s.boundingSphereRadius)continue;let a=null;e.material&&s.material&&(a=i.getContactMaterial(e.material,s.material)||null),this.currentContactMaterial=a||r||i.defaultContactMaterial;let h=this[e.type|s.type];if(h){let t=!1;(e.type<s.type?h.call(this,e,s,ep,ey,ev,em,n,o,e,s,l):h.call(this,s,e,ey,ep,em,ev,o,n,e,s,l))&&l&&(i.shapeOverlapKeeper.set(e.id,s.id),i.bodyOverlapKeeper.set(n.id,o.id))}}}}}sphereSphere(t,e,i,s,n,o,r,l,a,h,u){if(u)return i.distanceSquared(s)<(t.radius+e.radius)**2;let c=this.createContactEquation(r,l,t,e,a,h);s.vsub(i,c.ni),c.ni.normalize(),c.ri.copy(c.ni),c.rj.copy(c.ni),c.ri.scale(t.radius,c.ri),c.rj.scale(-e.radius,c.rj),c.ri.vadd(i,c.ri),c.ri.vsub(r.position,c.ri),c.rj.vadd(s,c.rj),c.rj.vsub(l.position,c.rj),this.result.push(c),this.createFrictionEquationsFromContact(c,this.frictionResult)}spherePlane(t,e,i,s,n,o,r,l,a,h,u){let c=this.createContactEquation(r,l,t,e,a,h);if(c.ni.set(0,0,1),o.vmult(c.ni,c.ni),c.ni.negate(c.ni),c.ni.normalize(),c.ni.scale(t.radius,c.ri),i.vsub(s,eI),c.ni.scale(c.ni.dot(eI),eL),eI.vsub(eL,c.rj),-eI.dot(c.ni)<=t.radius){if(u)return!0;let t=c.ri,e=c.rj;t.vadd(i,t),t.vsub(r.position,t),e.vadd(s,e),e.vsub(l.position,e),this.result.push(c),this.createFrictionEquationsFromContact(c,this.frictionResult)}}boxBox(t,e,i,s,n,o,r,l,a,h,u){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,i,s,n,o,r,l,t,e,u)}sphereBox(t,e,i,s,n,o,r,l,a,h,u){let c=this.v3pool;i.vsub(s,eW),e.getSideNormals(eG,o);let d=t.radius,p=!1,y=null,v=0,m=0,w=0,f=null;for(let t=0,e=eG.length;t!==e&&!1===p;t++){eV.copy(eG[t]);let e=eV.length();eV.normalize();let i=eW.dot(eV);if(i<e+d&&i>0){eH.copy(eG[(t+1)%3]),eD.copy(eG[(t+2)%3]);let s=eH.length(),n=eD.length();eH.normalize(),eD.normalize();let o=eW.dot(eH),r=eW.dot(eD);if(o<s&&o>-s&&r<n&&r>-n){let t=Math.abs(i-e-d);if((null===f||t<f)&&(f=t,m=o,w=r,y=e,e_.copy(eV),eU.copy(eH),eX.copy(eD),v++,u))return!0}}}if(v){p=!0;let n=this.createContactEquation(r,l,t,e,a,h);e_.scale(-d,n.ri),n.ni.copy(e_),n.ni.negate(n.ni),e_.scale(y,e_),eU.scale(m,eU),e_.vadd(eU,e_),eX.scale(w,eX),e_.vadd(eX,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}let g=c.get();for(let n=0;2!==n&&!p;n++)for(let o=0;2!==o&&!p;o++)for(let c=0;2!==c&&!p;c++)if(g.set(0,0,0),n?g.vadd(eG[0],g):g.vsub(eG[0],g),o?g.vadd(eG[1],g):g.vsub(eG[1],g),c?g.vadd(eG[2],g):g.vsub(eG[2],g),s.vadd(g,eY),eY.vsub(i,eY),eY.lengthSquared()<d*d){if(u)return!0;p=!0;let n=this.createContactEquation(r,l,t,e,a,h);n.ri.copy(eY),n.ri.normalize(),n.ni.copy(n.ri),n.ri.scale(d,n.ri),n.rj.copy(g),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}c.release(g),g=null;let x=c.get(),b=c.get(),E=c.get(),z=c.get(),S=c.get(),C=eG.length;for(let n=0;n!==C&&!p;n++)for(let o=0;o!==C&&!p;o++)if(n%3!=o%3){eG[o].cross(eG[n],x),x.normalize(),eG[n].vadd(eG[o],b),E.copy(i),E.vsub(b,E),E.vsub(s,E);let c=E.dot(x);x.scale(c,z);let y=0;for(;y===n%3||y===o%3;)y++;S.copy(i),S.vsub(z,S),S.vsub(b,S),S.vsub(s,S);let v=Math.abs(c),m=S.length();if(v<eG[y].length()&&m<d){if(u)return!0;p=!0;let n=this.createContactEquation(r,l,t,e,a,h);b.vadd(z,n.rj),n.rj.copy(n.rj),S.negate(n.ni),n.ni.normalize(),n.ri.copy(n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(i,n.ri),n.ri.normalize(),n.ri.scale(d,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}c.release(x,b,E,z,S)}planeBox(t,e,i,s,n,o,r,l,a,h,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,i,s,n,o,r,l,t,e,u)}convexConvex(t,e,i,s,n,o,r,l,a,h,u,c,d){if(!(i.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,i,n,s,o,e9,c,d)){let c=[];t.clipAgainstHull(i,n,e,s,o,e9,-100,100,c);let d=0;for(let n=0;n!==c.length;n++){if(u)return!0;let o=this.createContactEquation(r,l,t,e,a,h),p=o.ri,y=o.rj;e9.negate(o.ni),c[n].normal.negate(it),it.scale(c[n].depth,it),c[n].point.vadd(it,p),y.copy(c[n].point),p.vsub(i,p),y.vsub(s,y),p.vadd(i,p),p.vsub(r.position,p),y.vadd(s,y),y.vsub(l.position,y),this.result.push(o),d++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(o,this.frictionResult)}this.enableFrictionReduction&&d&&this.createFrictionFromAverage(d)}}sphereConvex(t,e,i,s,n,o,r,l,a,h,u){let c=this.v3pool;i.vsub(s,e$);let d=e.faceNormals,p=e.faces,y=e.vertices,v=t.radius,m=!1;for(let n=0;n!==y.length;n++){let c=y[n];if(o.vmult(c,eJ),s.vadd(eJ,eJ),eJ.vsub(i,eQ),eQ.lengthSquared()<v*v){if(u)return!0;m=!0;let n=this.createContactEquation(r,l,t,e,a,h);n.ri.copy(eQ),n.ri.normalize(),n.ni.copy(n.ri),n.ri.scale(v,n.ri),eJ.vsub(s,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);return}}for(let n=0,w=p.length;n!==w&&!1===m;n++){let w=d[n],f=p[n];o.vmult(w,e0),o.vmult(y[f[0]],e1),e1.vadd(s,e1),e0.scale(-v,e2),i.vadd(e2,e2),e2.vsub(e1,e3);let g=e3.dot(e0);if(i.vsub(e1,e6),g<0&&e6.dot(e0)>0){let n=[];for(let t=0,e=f.length;t!==e;t++){let e=c.get();o.vmult(y[f[t]],e),s.vadd(e,e),n.push(e)}if(function(t,e,i){let s=null,n=t.length;for(let o=0;o!==n;o++){let r=t[o];t[(o+1)%n].vsub(r,ej),ej.cross(e,eO),i.vsub(r,ek);let l=eO.dot(ek);if(null!==s&&(!(l>0)||!0!==s)&&(!(l<=0)||!1!==s))return!1;null===s&&(s=l>0)}return!0}(n,e0,i)){if(u)return!0;m=!0;let o=this.createContactEquation(r,l,t,e,a,h);e0.scale(-v,o.ri),e0.negate(o.ni);let d=c.get();e0.scale(-g,d);let p=c.get();e0.scale(-v,p),i.vsub(s,o.rj),o.rj.vadd(p,o.rj),o.rj.vadd(d,o.rj),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),c.release(d),c.release(p),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult);for(let t=0,e=n.length;t!==e;t++)c.release(n[t]);return}for(let d=0;d!==f.length;d++){let p=c.get(),m=c.get();o.vmult(y[f[(d+1)%f.length]],p),o.vmult(y[f[(d+2)%f.length]],m),s.vadd(p,p),s.vadd(m,m),m.vsub(p,eK),eK.unit(eZ);let w=c.get(),g=c.get();i.vsub(p,g);let x=g.dot(eZ);eZ.scale(x,w),w.vadd(p,w);let b=c.get();if(w.vsub(i,b),x>0&&x*x<eK.lengthSquared()&&b.lengthSquared()<v*v){if(u)return!0;let o=this.createContactEquation(r,l,t,e,a,h);w.vsub(s,o.rj),w.vsub(i,o.ni),o.ni.normalize(),o.ni.scale(v,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult);for(let t=0,e=n.length;t!==e;t++)c.release(n[t]);c.release(p),c.release(m),c.release(w),c.release(b),c.release(g);return}c.release(p),c.release(m),c.release(w),c.release(b),c.release(g)}for(let t=0,e=n.length;t!==e;t++)c.release(n[t])}}}planeConvex(t,e,i,s,n,o,r,l,a,h,u){e5.set(0,0,1),n.vmult(e5,e5);let c=0;for(let n=0;n!==e.vertices.length;n++)if(e4.copy(e.vertices[n]),o.vmult(e4,e4),s.vadd(e4,e4),e4.vsub(i,e7),0>=e5.dot(e7)){if(u)return!0;let n=this.createContactEquation(r,l,t,e,a,h);e5.scale(e5.dot(e7),e8),e4.vsub(e8,e8),e8.vsub(i,n.ri),n.ni.copy(e5),e4.vsub(s,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),c++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(n,this.frictionResult)}this.enableFrictionReduction&&c&&this.createFrictionFromAverage(c)}boxConvex(t,e,i,s,n,o,r,l,a,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,i,s,n,o,r,l,t,e,u)}sphereHeightfield(t,e,i,s,n,o,r,l,a,h,u){let c=e.data,d=t.radius,p=e.elementSize;C.pointToLocalFrame(s,o,i,iy);let y=Math.floor((iy.x-d)/p)-1,v=Math.ceil((iy.x+d)/p)+1,m=Math.floor((iy.y-d)/p)-1,w=Math.ceil((iy.y+d)/p)+1;if(v<0||w<0||y>c.length||m>c[0].length)return;y<0&&(y=0),v<0&&(v=0),m<0&&(m=0),w<0&&(w=0),y>=c.length&&(y=c.length-1),v>=c.length&&(v=c.length-1),w>=c[0].length&&(w=c[0].length-1),m>=c[0].length&&(m=c[0].length-1);let f=[];e.getRectMinMax(y,m,v,w,f);let g=f[0],x=f[1];if(iy.z-d>x||iy.z+d<g)return;let b=this.result;for(let a=y;a<v;a++)for(let h=m;h<w;h++){let c=b.length,d=!1;if(e.getConvexTrianglePillar(a,h,!1),C.pointToWorldFrame(s,o,e.pillarOffset,iv),i.distanceTo(iv)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(d=this.sphereConvex(t,e.pillarConvex,i,iv,n,o,r,l,t,e,u)),u&&d||(e.getConvexTrianglePillar(a,h,!0),C.pointToWorldFrame(s,o,e.pillarOffset,iv),i.distanceTo(iv)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(d=this.sphereConvex(t,e.pillarConvex,i,iv,n,o,r,l,t,e,u)),u&&d))return!0;if(b.length-c>2)return}}boxHeightfield(t,e,i,s,n,o,r,l,a,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,i,s,n,o,r,l,t,e,u)}convexHeightfield(t,e,i,s,n,o,r,l,a,h,u){let c=e.data,d=e.elementSize,p=t.boundingSphereRadius;C.pointToLocalFrame(s,o,i,ic);let y=Math.floor((ic.x-p)/d)-1,v=Math.ceil((ic.x+p)/d)+1,m=Math.floor((ic.y-p)/d)-1,w=Math.ceil((ic.y+p)/d)+1;if(v<0||w<0||y>c.length||m>c[0].length)return;y<0&&(y=0),v<0&&(v=0),m<0&&(m=0),w<0&&(w=0),y>=c.length&&(y=c.length-1),v>=c.length&&(v=c.length-1),w>=c[0].length&&(w=c[0].length-1),m>=c[0].length&&(m=c[0].length-1);let f=[];e.getRectMinMax(y,m,v,w,f);let g=f[0],x=f[1];if(!(ic.z-p>x)&&!(ic.z+p<g))for(let a=y;a<v;a++)for(let h=m;h<w;h++){let c=!1;if(e.getConvexTrianglePillar(a,h,!1),C.pointToWorldFrame(s,o,e.pillarOffset,id),i.distanceTo(id)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(c=this.convexConvex(t,e.pillarConvex,i,id,n,o,r,l,null,null,u,ip,null)),u&&c||(e.getConvexTrianglePillar(a,h,!0),C.pointToWorldFrame(s,o,e.pillarOffset,id),i.distanceTo(id)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(c=this.convexConvex(t,e.pillarConvex,i,id,n,o,r,l,null,null,u,ip,null)),u&&c))return!0}}sphereParticle(t,e,i,s,n,o,r,l,a,h,u){if(io.set(0,0,1),s.vsub(i,io),io.lengthSquared()<=t.radius*t.radius){if(u)return!0;let i=this.createContactEquation(l,r,e,t,a,h);io.normalize(),i.rj.copy(io),i.rj.scale(t.radius,i.rj),i.ni.copy(io),i.ni.negate(i.ni),i.ri.set(0,0,0),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}planeParticle(t,e,i,s,n,o,r,l,a,h,u){if(ie.set(0,0,1),r.quaternion.vmult(ie,ie),s.vsub(r.position,ii),0>=ie.dot(ii)){if(u)return!0;let i=this.createContactEquation(l,r,e,t,a,h);i.ni.copy(ie),i.ni.negate(i.ni),i.ri.set(0,0,0),ie.scale(ie.dot(s),is),s.vsub(is,is),i.rj.copy(is),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}boxParticle(t,e,i,s,n,o,r,l,a,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,i,s,n,o,r,l,t,e,u)}convexParticle(t,e,i,s,n,o,r,l,a,h,u){let c=-1,d=null;if(il.copy(s),il.vsub(i,il),n.conjugate(ir),ir.vmult(il,il),t.pointIsInside(il)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(i,n),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(n);for(let e=0,i=t.faces.length;e!==i;e++){let i=[t.worldVertices[t.faces[e][0]]],n=t.worldFaceNormals[e];s.vsub(i[0],ih);let o=-n.dot(ih);if(null===d||Math.abs(o)<Math.abs(d)){if(u)return!0;d=o,c=e,ia.copy(n)}}if(-1!==c){let n=this.createContactEquation(l,r,e,t,a,h);ia.scale(d,iu),iu.vadd(s,iu),iu.vsub(i,iu),n.rj.copy(iu),ia.negate(n.ni),n.ri.set(0,0,0);let o=n.ri,u=n.rj;o.vadd(s,o),o.vsub(l.position,o),u.vadd(i,u),u.vsub(r.position,u),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,i,s,n,o,r,l,a,h,u){return this.convexHeightfield(e,t,s,i,o,n,l,r,a,h,u)}particleCylinder(t,e,i,s,n,o,r,l,a,h,u){return this.convexParticle(e,t,s,i,o,n,l,r,a,h,u)}sphereTrimesh(t,e,i,s,n,o,r,l,a,h,u){C.pointToLocalFrame(s,o,i,eM);let c=t.radius;eP.lowerBound.set(eM.x-c,eM.y-c,eM.z-c),eP.upperBound.set(eM.x+c,eM.y+c,eM.z+c),e.getTrianglesInAABB(eP,eT);let d=t.radius*t.radius;for(let n=0;n<eT.length;n++)for(let c=0;c<3;c++)if(e.getVertex(e.indices[3*eT[n]+c],eE),eE.vsub(eM,eb),eb.lengthSquared()<=d){if(ez.copy(eE),C.pointToWorldFrame(s,o,ez,eE),eE.vsub(i,eb),u)return!0;let n=this.createContactEquation(r,l,t,e,a,h);n.ni.copy(eb),n.ni.normalize(),n.ri.copy(n.ni),n.ri.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.copy(eE),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}for(let n=0;n<eT.length;n++)for(let c=0;c<3;c++){e.getVertex(e.indices[3*eT[n]+c],eS),e.getVertex(e.indices[3*eT[n]+(c+1)%3],eC),eC.vsub(eS,eA),eM.vsub(eC,eF);let d=eF.dot(eA);eM.vsub(eS,eF);let p=eF.dot(eA);if(p>0&&d<0&&(eM.vsub(eS,eF),eB.copy(eA),eB.normalize(),p=eF.dot(eB),eB.scale(p,eF),eF.vadd(eS,eF),eF.distanceTo(eM)<t.radius)){if(u)return!0;let n=this.createContactEquation(r,l,t,e,a,h);eF.vsub(eM,n.ni),n.ni.normalize(),n.ni.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),C.pointToWorldFrame(s,o,eF,eF),eF.vsub(l.position,n.rj),C.vectorToWorldFrame(o,n.ni,n.ni),C.vectorToWorldFrame(o,n.ri,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}for(let n=0,c=eT.length;n!==c;n++){e.getTriangleVertices(eT[n],eN,eq,eR),e.getNormal(eT[n],ex),eM.vsub(eN,eF);let c=eF.dot(ex);if(ex.scale(c,eF),eM.vsub(eF,eF),c=eF.distanceTo(eM),to.pointInTriangle(eF,eN,eq,eR)&&c<t.radius){if(u)return!0;let n=this.createContactEquation(r,l,t,e,a,h);eF.vsub(eM,n.ni),n.ni.normalize(),n.ni.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),C.pointToWorldFrame(s,o,eF,eF),eF.vsub(l.position,n.rj),C.vectorToWorldFrame(o,n.ni,n.ni),C.vectorToWorldFrame(o,n.ri,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}eT.length=0}planeTrimesh(t,e,i,s,n,o,r,l,a,h,u){let c=new d;ew.set(0,0,1),n.vmult(ew,ew);for(let n=0;n<e.vertices.length/3;n++){e.getVertex(n,c);let p=new d;if(p.copy(c),C.pointToWorldFrame(s,o,p,c),c.vsub(i,ef),0>=ew.dot(ef)){if(u)return!0;let i=this.createContactEquation(r,l,t,e,a,h);i.ni.copy(ew),ew.scale(ef.dot(ew),eg),c.vsub(eg,eg),i.ri.copy(eg),i.ri.vsub(r.position,i.ri),i.rj.copy(c),i.rj.vsub(l.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}}}let eu=new d,ec=new d,ed=new d,ep=new d,ey=new d,ev=new b,em=new b,ew=new d,ef=new d,eg=new d,ex=new d,eb=new d;new d;let eE=new d,ez=new d,eS=new d,eC=new d,eA=new d,eB=new d,eM=new d,eF=new d,eN=new d,eq=new d,eR=new d,eP=new m,eT=[],eI=new d,eL=new d,ej=new d,eO=new d,ek=new d,eW=new d,eV=new d,eH=new d,eD=new d,eG=[new d,new d,new d,new d,new d,new d],eY=new d,e_=new d,eU=new d,eX=new d,e$=new d,eK=new d,eZ=new d,eQ=new d,eJ=new d,e0=new d,e1=new d,e2=new d,e3=new d,e6=new d;new d,new d;let e4=new d,e5=new d,e7=new d,e8=new d,e9=new d,it=new d,ie=new d,ii=new d,is=new d,io=new d,ir=new b,il=new d;new d;let ia=new d,ih=new d,iu=new d,ic=new d,id=new d,ip=[0],iy=new d,iv=new d;class im{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){let i=e;e=t,t=i}return t<<16|e}set(t,e){let i=this.getKey(t,e),s=this.current,n=0;for(;i>s[n];)n++;if(i!==s[n]){for(let t=s.length-1;t>=n;t--)s[t+1]=s[t];s[n]=i}}tick(){let t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){let i=this.current,s=this.previous,n=i.length,o=s.length,r=0;for(let e=0;e<n;e++){let n=!1,o=i[e];for(;o>s[r];)r++;o===s[r]||iw(t,o)}r=0;for(let t=0;t<o;t++){let n=!1,o=s[t];for(;o>i[r];)r++;i[r]===o||iw(e,o)}}}function iw(t,e){t.push((0xffff0000&e)>>16,65535&e)}let ig=(t,e)=>t<e?`${t}-${e}`:`${e}-${t}`;class ix{constructor(){this.data={keys:[]}}get(t,e){let i=ig(t,e);return this.data[i]}set(t,e,i){let s=ig(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=i}delete(t,e){let i=ig(t,e),s=this.data.keys.indexOf(i);-1!==s&&this.data.keys.splice(s,1),delete this.data[i]}reset(){let t=this.data,e=t.keys;for(;e.length>0;){let i=e.pop();delete t[i]}}}class ib extends x{constructor(t){void 0===t&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==t.quatNormalizeSkip?t.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==t.quatNormalizeFast&&t.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new d,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new d,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=void 0!==t.broadphase?t.broadphase:new ti,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==t.solver?t.solver:new ei,this.constraints=[],this.narrowphase=new eh(this),this.collisionMatrix=new g,this.collisionMatrixPrevious=new g,this.bodyOverlapKeeper=new im,this.shapeOverlapKeeper=new im,this.contactmaterials=[],this.contactMaterialTable=new ix,this.defaultMaterial=new t3("default"),this.defaultContactMaterial=new t2(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){let t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){let e=this.constraints.indexOf(t);-1!==e&&this.constraints.splice(e,1)}rayTest(t,e,i){i instanceof ts?this.raycastClosest(t,e,{skipBackfaces:!0},i):this.raycastAll(t,e,{skipBackfaces:!0},i)}raycastAll(t,e,i,s){return void 0===i&&(i={}),i.mode=to.ALL,i.from=t,i.to=e,i.callback=s,iE.intersectWorld(this,i)}raycastAny(t,e,i,s){return void 0===i&&(i={}),i.mode=to.ANY,i.from=t,i.to=e,i.result=s,iE.intersectWorld(this,i)}raycastClosest(t,e,i,s){return void 0===i&&(i={}),i.mode=to.CLOSEST,i.from=t,i.to=e,i.result=s,iE.intersectWorld(this,i)}addBody(t){!this.bodies.includes(t)&&(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof j&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;let e=this.bodies.length-1,i=this.bodies,s=i.indexOf(t);if(-1!==s){i.splice(s,1);for(let t=0;t!==i.length;t++)i[t].index=t;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){let e=this.bodies;for(let i=0;i<e.length;i++){let s=e[i].shapes;for(let e=0;e<s.length;e++){let i=s[e];if(i.id===t)return i}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){let e=this.contactmaterials.indexOf(t);-1!==e&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){void 0===t&&(t=1/60),void 0===e&&(e=10);let i=iz.now()/1e3;if(this.lastCallTime){let s=i-this.lastCallTime;this.step(t,s,e)}else this.step(t,void 0,e);this.lastCallTime=i}step(t,e,i){if(void 0===i&&(i=10),void 0===e)this.internalStep(t),this.time+=t;else{this.accumulator+=e;let s=iz.now(),n=0;for(;this.accumulator>=t&&n<i&&(this.internalStep(t),this.accumulator-=t,n++,!(iz.now()-s>1e3*t)););this.accumulator=this.accumulator%t;let o=this.accumulator/t;for(let t=0;t!==this.bodies.length;t++){let e=this.bodies[t];e.previousPosition.lerp(e.position,o,e.interpolatedPosition),e.previousQuaternion.slerp(e.quaternion,o,e.interpolatedQuaternion),e.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;let e=this.contacts,i=this.bodies.length,s=this.bodies,n=this.solver,o=this.gravity,r=this.doProfiling,l=this.profile,a=j.DYNAMIC,h=-1/0,u=this.constraints;o.length();let c=o.x,d=o.y,p=o.z,y=0;for(r&&(h=iz.now()),y=0;y!==i;y++){let t=s[y];if(t.type===a){let e=t.force,i=t.mass;e.x+=i*c,e.y+=i*d,e.z+=i*p}}for(let t=0,e=this.subsystems.length;t!==e;t++)this.subsystems[t].update();r&&(h=iz.now()),iF.length=0,iN.length=0,this.broadphase.collisionPairs(this,iF,iN),r&&(l.broadphase=iz.now()-h);let v=u.length;for(y=0;y!==v;y++){let t=u[y];if(!t.collideConnected)for(let e=iF.length-1;e>=0;e-=1)(t.bodyA===iF[e]&&t.bodyB===iN[e]||t.bodyB===iF[e]&&t.bodyA===iN[e])&&(iF.splice(e,1),iN.splice(e,1))}this.collisionMatrixTick(),r&&(h=iz.now());let m=e.length;for(y=0;y!==m;y++)iB.push(e[y]);e.length=0;let w=this.frictionEquations.length;for(y=0;y!==w;y++)iM.push(this.frictionEquations[y]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(iF,iN,this,e,iB,this.frictionEquations,iM),r&&(l.narrowphase=iz.now()-h),r&&(h=iz.now()),y=0;y<this.frictionEquations.length;y++)n.addEquation(this.frictionEquations[y]);let f=e.length;for(let t=0;t!==f;t++){let i;let s=e[t],o=s.bi,r=s.bj,l=s.si,a=s.sj;(o.material&&r.material&&this.getContactMaterial(o.material,r.material)||this.defaultContactMaterial).friction,o.material&&r.material&&(o.material.friction>=0&&r.material.friction>=0&&(o.material.friction,r.material.friction),o.material.restitution>=0&&r.material.restitution>=0&&(s.restitution=o.material.restitution*r.material.restitution)),n.addEquation(s),o.allowSleep&&o.type===j.DYNAMIC&&o.sleepState===j.SLEEPING&&r.sleepState===j.AWAKE&&r.type!==j.STATIC&&r.velocity.lengthSquared()+r.angularVelocity.lengthSquared()>=2*r.sleepSpeedLimit**2&&(o.wakeUpAfterNarrowphase=!0),r.allowSleep&&r.type===j.DYNAMIC&&r.sleepState===j.SLEEPING&&o.sleepState===j.AWAKE&&o.type!==j.STATIC&&o.velocity.lengthSquared()+o.angularVelocity.lengthSquared()>=2*o.sleepSpeedLimit**2&&(r.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(o,r,!0),this.collisionMatrixPrevious.get(o,r)||(iA.body=r,iA.contact=s,o.dispatchEvent(iA),iA.body=o,r.dispatchEvent(iA)),this.bodyOverlapKeeper.set(o.id,r.id),this.shapeOverlapKeeper.set(l.id,a.id)}for(this.emitContactEvents(),r&&(l.makeContactConstraints=iz.now()-h,h=iz.now()),y=0;y!==i;y++){let t=s[y];t.wakeUpAfterNarrowphase&&(t.wakeUp(),t.wakeUpAfterNarrowphase=!1)}for(y=0,v=u.length;y!==v;y++){let t=u[y];t.update();for(let e=0,i=t.equations.length;e!==i;e++){let i=t.equations[e];n.addEquation(i)}}n.solve(t,this),r&&(l.solve=iz.now()-h),n.removeAllEquations();let g=Math.pow;for(y=0;y!==i;y++){let e=s[y];if(e.type&a){let i=g(1-e.linearDamping,t),s=e.velocity;s.scale(i,s);let n=e.angularVelocity;if(n){let i=g(1-e.angularDamping,t);n.scale(i,n)}}}this.dispatchEvent(iC),r&&(h=iz.now());let x=this.stepnumber%(this.quatNormalizeSkip+1)==0,b=this.quatNormalizeFast;for(y=0;y!==i;y++)s[y].integrate(t,x,b);this.clearForces(),this.broadphase.dirty=!0,r&&(l.integrate=iz.now()-h),this.stepnumber+=1,this.dispatchEvent(iS);let E=!0;if(this.allowSleep)for(y=0,E=!1;y!==i;y++){let t=s[y];t.sleepTick(this.time),t.sleepState!==j.SLEEPING&&(E=!0)}this.hasActiveBodies=E}emitContactEvents(){let t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(iq,iR),t){for(let t=0,e=iq.length;t<e;t+=2)iP.bodyA=this.getBodyById(iq[t]),iP.bodyB=this.getBodyById(iq[t+1]),this.dispatchEvent(iP);iP.bodyA=iP.bodyB=null}if(e){for(let t=0,e=iR.length;t<e;t+=2)iT.bodyA=this.getBodyById(iR[t]),iT.bodyB=this.getBodyById(iR[t+1]),this.dispatchEvent(iT);iT.bodyA=iT.bodyB=null}iq.length=iR.length=0;let i=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((i||s)&&this.shapeOverlapKeeper.getDiff(iq,iR),i){for(let t=0,e=iq.length;t<e;t+=2){let e=this.getShapeById(iq[t]),i=this.getShapeById(iq[t+1]);iI.shapeA=e,iI.shapeB=i,e&&(iI.bodyA=e.body),i&&(iI.bodyB=i.body),this.dispatchEvent(iI)}iI.bodyA=iI.bodyB=iI.shapeA=iI.shapeB=null}if(s){for(let t=0,e=iR.length;t<e;t+=2){let e=this.getShapeById(iR[t]),i=this.getShapeById(iR[t+1]);iL.shapeA=e,iL.shapeB=i,e&&(iL.bodyA=e.body),i&&(iL.bodyB=i.body),this.dispatchEvent(iL)}iL.bodyA=iL.bodyB=iL.shapeA=iL.shapeB=null}}clearForces(){let t=this.bodies,e=t.length;for(let i=0;i!==e;i++){let e=t[i];e.force,e.torque,e.force.set(0,0,0),e.torque.set(0,0,0)}}}new m;let iE=new to,iz=globalThis.performance||{};if(!iz.now){let t=Date.now();iz.timing&&iz.timing.navigationStart&&(t=iz.timing.navigationStart),iz.now=()=>Date.now()-t}new d;let iS={type:"postStep"},iC={type:"preStep"},iA={type:j.COLLIDE_EVENT_NAME,body:null,contact:null},iB=[],iM=[],iF=[],iN=[],iq=[],iR=[],iP={type:"beginContact",bodyA:null,bodyB:null},iT={type:"endContact",bodyA:null,bodyB:null},iI={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},iL={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null}}}]);